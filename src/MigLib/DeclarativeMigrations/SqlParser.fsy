%{
open migrate.DeclarativeMigrations.Types

let parseAnnotationsFromComments (comments: string list) =
  let queryBy = ResizeArray<QueryByAnnotation>()
  let queryByOrCreate = ResizeArray<QueryByOrCreateAnnotation>()
  let insertOrIgnore = ResizeArray<InsertOrIgnoreAnnotation>()

  let parseColumns (cols: string) =
    cols.Split(',')
    |> Array.map (fun c -> c.Trim())
    |> Array.filter (fun c -> c <> "")
    |> Array.toList

  let tryMatch (pattern: string) (line: string) =
    let m =
      System.Text.RegularExpressions.Regex.Match(
        line.Trim(),
        pattern,
        System.Text.RegularExpressions.RegexOptions.IgnoreCase
      )
    if m.Success then Some m else None

  for line in comments do
    match tryMatch @"^QueryBy\s*\((.*)\)\s*$" line with
    | Some m ->
      let cols = parseColumns m.Groups.[1].Value
      if cols.Length > 0 then
        queryBy.Add({ columns = cols })
    | None ->
      match tryMatch @"^QueryByOrCreate\s*\((.*)\)\s*$" line with
      | Some m ->
        let cols = parseColumns m.Groups.[1].Value
        if cols.Length > 0 then
          queryByOrCreate.Add({ columns = cols })
      | None ->
        match tryMatch @"^InsertOrIgnore(?:\s*\(\s*\))?\s*$" line with
        | Some _ -> insertOrIgnore.Add(InsertOrIgnoreAnnotation)
        | None -> ()

  (List.ofSeq queryBy, List.ofSeq queryByOrCreate, List.ofSeq insertOrIgnore)

let tokensToString (xs: string list) =
  match xs with
  | [single] -> single
  | _ ->
    xs
    |> List.pairwise
    |> List.mapi (fun i (pred, curr) ->
      if i = 0 then
        pred + " " + curr
      else
        match pred, curr with
        | ",", _ -> " " + curr
        | _, ","
        | _, "."
        | ".", _
        | _, ")"
        | _, "(" -> curr
        | _ -> " " + curr)
    |> String.concat ""

// Note: precedence intentionally left simple; current grammar accepts several shift/reduce defaults.

%}

%token <string> IDENT
%token <string> STRING_LIT
%token <int> INT_LIT
%token <float> FLOAT_LIT
%token <string> COMMENT

%token CREATE TABLE VIEW INDEX TRIGGER
%token PRIMARY KEY FOREIGN REFERENCES
%token UNIQUE NOT NULL DEFAULT CHECK AUTOINCREMENT
%token TINTEGER TTEXT TREAL TTIMESTAMP TSTRING
%token IF EXISTS ON AS
%token INSERT INTO VALUES
%token DELETE CASCADE RESTRICT SET UPDATE NO ACTION
%token TEMPORARY TEMP
%token OR REPLACE IGNORE
%token CONSTRAINT
%token AND

%token LPAREN RPAREN COMMA SEMI DOT STAR
%token EQ LT GT LE GE NE NE2
%token PLUS MINUS SLASH CONCAT
%token EOF

%right COMMENT CREATE INSERT

%start file
%type <SqlFile> file

%%

file:
  | statements EOF { $1 }

statements:
  | { emptyFile }
  | statements statement
    { let (f: SqlFile), s = $1, $2
      match s with
      | Some (Choice1Of5 t) -> { f with tables = f.tables @ [t] }
      | Some (Choice2Of5 v) -> { f with views = f.views @ [v] }
      | Some (Choice3Of5 i) -> { f with indexes = f.indexes @ [i] }
      | Some (Choice4Of5 t) -> { f with triggers = f.triggers @ [t] }
      | Some (Choice5Of5 i) -> { f with inserts = f.inserts @ [i] }
      | None -> f }

statement:
  | create_table opt_semi comments %prec COMMENT
    { let (t: CreateTable) = $1
      let cs = $3
      let (qb, qboc, ioi) = parseAnnotationsFromComments cs
      Some (Choice1Of5 { t with
                          queryByAnnotations = qb
                          queryByOrCreateAnnotations = qboc
                          insertOrIgnoreAnnotations = ioi }) }
  | create_view opt_semi comments %prec COMMENT
    { let (v: CreateView) = $1
      let cs = $3
      let (qb, qboc, ioi) = parseAnnotationsFromComments cs
      Some (Choice2Of5 { v with
                          queryByAnnotations = qb
                          queryByOrCreateAnnotations = qboc
                          insertOrIgnoreAnnotations = ioi }) }
  | create_index opt_semi
    { Some (Choice3Of5 $1) }
  | create_trigger opt_semi
    { Some (Choice4Of5 $1) }
  | insert_into opt_semi
    { Some (Choice5Of5 $1) }
  | COMMENT
    { None }

comments:
  | { [] }
  | comments COMMENT { $1 @ [$2] }

opt_semi:
  | { () }
  | SEMI { () }

/* CREATE TABLE */

create_table:
  | CREATE TABLE opt_if_not_exists ident LPAREN table_items RPAREN
    { let items = $6
      let columns = items |> List.choose (function Choice1Of2 c -> Some c | _ -> None)
      let constraints = items |> List.choose (function Choice2Of2 c -> Some c | _ -> None)
      ({ name = $4
         columns = columns
         constraints = constraints
         queryByAnnotations = []
         queryByOrCreateAnnotations = []
         insertOrIgnoreAnnotations = [] }: CreateTable) }

opt_if_not_exists:
  | { () }
  | IF NOT EXISTS { () }

table_items:
  | table_item { [$1] }
  | table_items COMMA table_item { $1 @ [$3] }

table_item:
  | column_def { Choice1Of2 $1 }
  | table_constraint { Choice2Of2 $1 }

column_def:
  | ident sql_type column_constraints
    { { name = $1; columnType = $2; constraints = $3 } }

sql_type:
  | TINTEGER { SqlInteger }
  | TTEXT { SqlText }
  | TREAL { SqlReal }
  | TTIMESTAMP { SqlTimestamp }
  | TSTRING { SqlString }
  | { SqlFlexible }

column_constraints:
  | { [] }
  | column_constraints column_constraint { $1 @ [$2] }

column_constraint:
  | NOT NULL { NotNull }
  | PRIMARY KEY opt_autoincrement
    { PrimaryKey { constraintName = None; columns = []; isAutoincrement = $3 } }
  | UNIQUE { Unique [] }
  | DEFAULT expression { Default $2 }
  | CHECK LPAREN check_tokens RPAREN { Check $3 }
  | REFERENCES ident opt_id_list opt_fk_actions
    { let onDel, onUpd = $4
      ForeignKey { columns = []
                   refTable = $2
                   refColumns = $3 |> Option.defaultValue []
                   onDelete = onDel
                   onUpdate = onUpd } }

opt_autoincrement:
  | { false }
  | AUTOINCREMENT { true }

table_constraint:
  | PRIMARY KEY LPAREN id_list RPAREN
    { PrimaryKey { constraintName = None; columns = $4; isAutoincrement = false } }
  | CONSTRAINT ident PRIMARY KEY LPAREN id_list RPAREN
    { PrimaryKey { constraintName = Some $2; columns = $6; isAutoincrement = false } }
  | FOREIGN KEY LPAREN id_list RPAREN REFERENCES ident opt_id_list opt_fk_actions
    { let onDel, onUpd = $9
      ForeignKey { columns = $4
                   refTable = $7
                   refColumns = $8 |> Option.defaultValue []
                   onDelete = onDel
                   onUpdate = onUpd } }
  | UNIQUE LPAREN id_list RPAREN
    { Unique $3 }

id_list:
  | ident { [$1] }
  | id_list COMMA ident { $1 @ [$3] }

opt_id_list:
  | { None }
  | LPAREN id_list RPAREN { Some $2 }

opt_fk_actions:
  | { (None, None) }
  | opt_fk_actions ON DELETE fk_action
    { let (_, onUpd) = $1 in (Some $4, onUpd) }
  | opt_fk_actions ON UPDATE fk_action
    { let (onDel, _) = $1 in (onDel, Some $4) }

fk_action:
  | CASCADE { Cascade }
  | RESTRICT { Restrict }
  | NO ACTION { NoAction }
  | SET NULL { SetNull }
  | SET DEFAULT { SetDefault }

/* Expressions (for DEFAULT values) */

expression:
  | STRING_LIT { String $1 }
  | INT_LIT { Integer $1 }
  | FLOAT_LIT { Real $1 }
  | MINUS INT_LIT { Integer (- $2) }
  | MINUS FLOAT_LIT { Real (- $2) }
  | LPAREN paren_tokens RPAREN
    { let inner = $2 |> String.concat ""
      Value ("(" + inner + ")") }
  | ident { Value $1 }

paren_tokens:
  | { [] }
  | paren_tokens paren_token { $1 @ [$2] }

paren_token:
  | ident { $1 }
  | STRING_LIT { "'" + $1 + "'" }
  | INT_LIT { string $1 }
  | FLOAT_LIT { string $1 }
  | COMMA { ", " }
  | DOT { "." }
  | STAR { "*" }
  | EQ { "=" }
  | LT { "<" }
  | GT { ">" }
  | LE { "<=" }
  | GE { ">=" }
  | NE { "<>" }
  | NE2 { "!=" }
  | PLUS { "+" }
  | MINUS { "-" }
  | SLASH { "/" }
  | CONCAT { "||" }
  | LPAREN paren_tokens RPAREN { "(" + (String.concat "" $2) + ")" }
  | CREATE { "CREATE" }
  | TABLE { "TABLE" }
  | VIEW { "VIEW" }
  | INDEX { "INDEX" }
  | TRIGGER { "TRIGGER" }
  | PRIMARY { "PRIMARY" }
  | KEY { "KEY" }
  | FOREIGN { "FOREIGN" }
  | REFERENCES { "REFERENCES" }
  | UNIQUE { "UNIQUE" }
  | NOT { "NOT" }
  | NULL { "NULL" }
  | DEFAULT { "DEFAULT" }
  | CHECK { "CHECK" }
  | AUTOINCREMENT { "AUTOINCREMENT" }
  | TINTEGER { "INTEGER" }
  | TTEXT { "TEXT" }
  | TREAL { "REAL" }
  | TTIMESTAMP { "TIMESTAMP" }
  | TSTRING { "STRING" }
  | IF { "IF" }
  | EXISTS { "EXISTS" }
  | ON { "ON" }
  | AS { "AS" }
  | INSERT { "INSERT" }
  | INTO { "INTO" }
  | VALUES { "VALUES" }
  | DELETE { "DELETE" }
  | CASCADE { "CASCADE" }
  | RESTRICT { "RESTRICT" }
  | SET { "SET" }
  | UPDATE { "UPDATE" }
  | NO { "NO" }
  | ACTION { "ACTION" }
  | TEMPORARY { "TEMPORARY" }
  | TEMP { "TEMP" }
  | OR { "OR" }
  | REPLACE { "REPLACE" }
  | IGNORE { "IGNORE" }
  | CONSTRAINT { "CONSTRAINT" }

/* CHECK constraint tokens (balanced parens, any tokens) */

check_tokens:
  | { [] }
  | check_tokens check_token { $1 @ [$2] }

check_token:
  | ident { $1 }
  | STRING_LIT { "'" + $1 + "'" }
  | INT_LIT { string $1 }
  | FLOAT_LIT { string $1 }
  | COMMA { "," }
  | DOT { "." }
  | STAR { "*" }
  | EQ { "=" }
  | LT { "<" }
  | GT { ">" }
  | LE { "<=" }
  | GE { ">=" }
  | NE { "<>" }
  | NE2 { "!=" }
  | PLUS { "+" }
  | MINUS { "-" }
  | SLASH { "/" }
  | CONCAT { "||" }
  | ON { "ON" }
  | NOT { "NOT" }
  | NULL { "NULL" }
  | AND { "AND" }
  | OR { "OR" }
  | AS { "AS" }
  | IF { "IF" }
  | TINTEGER { "INTEGER" }
  | TTEXT { "TEXT" }
  | TREAL { "REAL" }
  | LPAREN check_tokens RPAREN
    { let inner = $2 |> String.concat " "
      "(" + inner + ")" }

/* CREATE VIEW */

create_view:
  | CREATE opt_temp VIEW opt_if_not_exists ident AS raw_tokens %prec COMMENT
    { let viewName = $5
      let rawTokens = $7
      let fullStatement = "CREATE VIEW " + viewName + " AS " + (tokensToString rawTokens)
      let selectPart = rawTokens |> Seq.map id |> String.concat " "
      let fromMatches =
        System.Text.RegularExpressions.Regex.Matches(
          selectPart,
          @"(?:FROM|JOIN)\s+(\w+)",
          System.Text.RegularExpressions.RegexOptions.IgnoreCase)
      let dependencies =
        [ for m in fromMatches do yield m.Groups.[1].Value ]
        |> List.distinct
      ({ name = viewName
         sqlTokens = [ fullStatement ]
         dependencies = dependencies
         queryByAnnotations = []
         queryByOrCreateAnnotations = []
         insertOrIgnoreAnnotations = [] }: CreateView) }

opt_temp:
  | { () }
  | TEMPORARY { () }
  | TEMP { () }

/* CREATE INDEX */

create_index:
  | CREATE opt_unique INDEX opt_if_not_exists ident ON ident LPAREN id_list RPAREN
    { { name = $5; table = $7; columns = $9 } }

opt_unique:
  | { () }
  | UNIQUE { () }

/* CREATE TRIGGER */

create_trigger:
  | CREATE opt_temp TRIGGER opt_if_not_exists ident raw_tokens %prec COMMENT
    { let triggerName = $5
      let rawTokens = $6
      let sql = tokensToString rawTokens
      let onMatch =
        System.Text.RegularExpressions.Regex.Match(
          sql,
          @"ON\s+(\w+)",
          System.Text.RegularExpressions.RegexOptions.IgnoreCase)
      let table = if onMatch.Success then onMatch.Groups.[1].Value else ""
      { name = triggerName
        sqlTokens = [ sql ]
        dependencies = if System.String.IsNullOrEmpty table then [] else [ table ] } }

/* INSERT INTO */

insert_into:
  | INSERT opt_or_replace INTO ident LPAREN id_list RPAREN VALUES value_lists
    { { table = $4; columns = $6; values = $9 } }

opt_or_replace:
  | { () }
  | OR REPLACE { () }
  | OR IGNORE { () }

value_lists:
  | value_list { [$1] }
  | value_lists COMMA value_list { $1 @ [$3] }

value_list:
  | LPAREN expr_list RPAREN { $2 }

expr_list:
  | expression { [$1] }
  | expr_list COMMA expression { $1 @ [$3] }

/* Raw tokens for views and triggers (any token except SEMI and EOF) */

raw_tokens:
  | raw_token { [$1] }
  | raw_tokens raw_token { $1 @ [$2] }

raw_token:
  | ident { $1 }
  | STRING_LIT { "'" + $1 + "'" }
  | INT_LIT { string $1 }
  | FLOAT_LIT { string $1 }
  | COMMENT { "--" + $1 }
  | LPAREN { "(" }
  | RPAREN { ")" }
  | COMMA { "," }
  | DOT { "." }
  | STAR { "*" }
  | EQ { "=" }
  | LT { "<" }
  | GT { ">" }
  | LE { "<=" }
  | GE { ">=" }
  | NE { "<>" }
  | NE2 { "!=" }
  | PLUS { "+" }
  | MINUS { "-" }
  | SLASH { "/" }
  | CONCAT { "||" }
  | CREATE { "CREATE" }
  | TABLE { "TABLE" }
  | VIEW { "VIEW" }
  | INDEX { "INDEX" }
  | TRIGGER { "TRIGGER" }
  | PRIMARY { "PRIMARY" }
  | KEY { "KEY" }
  | FOREIGN { "FOREIGN" }
  | REFERENCES { "REFERENCES" }
  | UNIQUE { "UNIQUE" }
  | NOT { "NOT" }
  | NULL { "NULL" }
  | DEFAULT { "DEFAULT" }
  | CHECK { "CHECK" }
  | AUTOINCREMENT { "AUTOINCREMENT" }
  | TINTEGER { "INTEGER" }
  | TTEXT { "TEXT" }
  | TREAL { "REAL" }
  | TTIMESTAMP { "TIMESTAMP" }
  | TSTRING { "STRING" }
  | IF { "IF" }
  | EXISTS { "EXISTS" }
  | ON { "ON" }
  | AS { "AS" }
  | INSERT { "INSERT" }
  | INTO { "INTO" }
  | VALUES { "VALUES" }
  | DELETE { "DELETE" }
  | CASCADE { "CASCADE" }
  | RESTRICT { "RESTRICT" }
  | SET { "SET" }
  | UPDATE { "UPDATE" }
  | NO { "NO" }
  | ACTION { "ACTION" }
  | TEMPORARY { "TEMPORARY" }
  | TEMP { "TEMP" }
  | OR { "OR" }
  | REPLACE { "REPLACE" }
  | IGNORE { "IGNORE" }
  | CONSTRAINT { "CONSTRAINT" }
  | AND { "AND" }

/* Identifiers - both plain IDENT and keywords used as identifiers */

ident:
  | IDENT { $1 }

%%
